# 混叠、克隆

### 复制列表

- 在处理可变对象时，直接修改列表可能不方便。相反，我们可以创建列表的副本。

- 在 Python 中复制列表的语法是：

  ```python
  Lcopy = Loriginal[:]
  ```

  这会在内存中创建一个新的列表对象，其元素与 Loriginal相同。

- 例子

```python
Loriginal = [4, 5, 6] 
Lnew = Loriginal[:]
```

- 现在，`Loriginal` 和 `Lnew` 是内存中的独立对象。修改一个不会影响另一个。

#### 练习：函数 `remove_all`

**任务：** 编写一个函数 `remove_all(L, E)`，使输入列表 `L` 仅保留不匹配 `E` 的元素。

##### 实现 `remove_all` 的步骤

1. **复制列表：** 首先，将原始列表 `L` 保存到一个新副本中。
2. **清空列表：** 使用 `L.clear()` 清空原始列表。
3. **迭代并附加：** 对于复制列表中的每个元素，如果不等于 `E`，则将其附加回 `L`。

#### 代码实现

```python
def remove_all(L, E):
    Lnew = L[:]  # 步骤 1：复制列表
    L.clear()    # 步骤 2：清空原始列表
    for n in Lnew:  # 步骤 3：迭代副本
        if n != E:
            L.append(n)  # 如果不等于 E，则附加
```

### 列表操作：移除元素

有几种方法可以从列表中移除项目：

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| `del`    | 移除特定索引处的项目。例如：`del L[index]` 移除索引为 `index` 的项目。 |
| `pop`    | 移除列表中的最后一个项目并返回它。例如：`L.pop()` 移除最后一个项目。 |
| `remove` | 移除指定值的第一次出现。例如：`L.remove(value)` 移除 `value`。 |

1. **使用 `del`：**

   ```python
   del L[0]  # 删除第一个元素
   ```

2. **使用 `pop`：**

   ```python
   last_item = L.pop()  # 删除并返回最后一个项目
   ```

3. **使用 `remove`：**

   ```python
   L.remove(3)  # 删除元素 3 的第一次出现
   ```

### 列表修改的关键点

| 方法     | 行为                                       | 返回值           |
| -------- | ------------------------------------------ | ---------------- |
| `del`    | 移除指定索引处的元素                       | None             |
| `pop`    | 移除并返回最后一个元素（或指定索引的元素） | 最后一个元素的值 |
| `remove` | 移除指定值的第一次出现                     | None             |

#### 重要说明

- `remove` 方法仅删除元素的第一次出现。要删除所有出现，必须遍历列表并多次调用 `remove`。
- `pop` 方法可以通过索引调用，以从特定位置删除项目，例如，`L.pop(2)` 删除索引 2 处的项目。如果不带参数调用，则删除最后一个项目。

#### 循环中删除的问题

- 场景：如果你有一个列表*L*=[1,2,2]，并且想要删除所有2的实例，使用 for 循环可能会导致跳过元素。
- 行为
  - 删除一个元素会导致后续元素移动，但循环的索引不会相应调整。

##### 意外行为示例

```python
def remove_all(L,e):
	for elem in L:
    	if elem == e:
       	 	L.remove(e)
L=[1,2,2,2]
remove_all(L,2)
print(L) # should print [1]
但是打印出来的是却是[1,2]
原因是列表是从第一个遇到2时候删除的但是指针是逐渐向后移动   
```

#### 删除重复项

该函数旨在通过删除在 `L2` 中找到的元素来变更 `L1`。

##### 有问题的代码示例

```python
L1 = [10, 20, 30, 40]
L2 = [10, 20, 50, 60] 
for e in L1:    
    if e in L2:        
        L1.remove(e)
```

- **问题**：在遍历 `L1` 时变更 `L1` 可能导致跳过元素。

##### 正确的方法

- 创建 `L1` 的副本进行遍历：

```python
def remove_duplicates(L1, L2):
    L1_copy = L1[:]  # 创建 L1 的副本 
for e in L1_copy:    
    if e in L2:        
        L1.remove(e)
```

- 这通过遍历原始列表的稳定副本来防止跳过元素。

#### 使用副本

> "使用副本，也称为克隆，可以帮助你跟踪原始列表中的值，而不会意外覆盖或移除它们。"

##### **关键要点**：在遍历时变更列表时，始终考虑对索引的影响，并使用副本或替代结构以避免意外行为。

#### 别名解释

- **别名**是指向内存中同一对象的另一个名称。
- 在编程中，如果使用等号将一个列表赋值给另一个（例如，( L1_copy = L1 )），你创建的是别名，而不是副本。

##### 重要区别

- 如果通过其别名修改原始列表，别名将反映这些更改，因为两者都指向同一内存位置。

| 操作             | 效果                   |
| ---------------- | ---------------------- |
| ( L1_copy = L1 ) | 创建别名，而不是副本   |
| 修改 ( L1 )      | ( L1_copy ) 也反映更改 |

#### 通过函数参数进行修改

- 在函数定义中，**形式参数**是指在函数定义中使用的变量，而 **实际参数** 是在函数调用时传递的值。
- 当可变对象被传递到函数中时，形式参数成为实际参数的别名。

| 特性           | `[:]`（切片操作）                | `copy.copy()`                          |
| -------------- | -------------------------------- | -------------------------------------- |
| **适用对象**   | 仅适用于列表（或其他可迭代对象） | 适用于任何对象（如列表、字典、集合等） |
| **拷贝类型**   | 浅拷贝                           | 浅拷贝                                 |
| **适用场景**   | 简单的列表拷贝                   | 通用的对象拷贝                         |
| **语法简洁度** | 简洁、易读                       | 稍显冗长，但适用范围更广               |
| **扩展性**     | 仅限于列表或可迭代对象           | 适用多种数据结构和自定义对象           |
| **性能**       | 一般来说较快                     | 可能稍微慢一些（因为是调用库函数）     |

### 浅拷贝与深拷贝

- **浅拷贝**：使用 `L1_copy = L1[:]` 对于包含其他可变列表的列表仍然指向相同的内部列表。
- **深拷贝**：深拷贝创建一个新列表并递归复制所有元素，确保嵌套对象也被复制。

#### 浅拷贝

- 浅拷贝创建一个新列表，但将原始列表中的对象引用插入其中。
- 对原始列表中可变元素的更改将在浅拷贝中反映出来。
- 浅拷贝只是复制了容器（如列表、字典）的最外层结构，但内部的元素（如果是可变对象）并没有被复制，而只是复制了它们的引用。所以，当你对浅拷贝后的列表中的可变元素进行修改时，原始列表中对应的元素也会受到影响。

```python
import copy
old_list = [[1,2],[3,4],[5,6]]
new_list = copy.copy(old_list)
old_list.append([7,8])
old_list[1][1] = 9
print("新列表:", new_list)  # 输出: [[1, 2], [3, 9], [5, 6]]
print("旧列表:", old_list)   # 输出: [[1, 2], [3, 9], [5, 6], [7, 8]]
```

#### 深拷贝

- 深拷贝创建一个新列表，并递归地添加原始列表中找到的嵌套对象的副本。
- 对原始列表中可变元素的更改将 **不** 影响深拷贝。
- 递归复制容器及其内的所有对象，所有对象都是独立的，不会互相影响。

**示例：**

```python
import copy 
old_list = [[1,2],[3,4],[5,6]] 
new_list = copy.deepcopy(old_list) old_list.append([7,8]) 
old_list[1][1] = 9 
print("新列表:", new_list)  # 输出: [[1,2],[3,4],[5,6]] print("旧列表:", old_list)   # 输出: [[1,2],[3,9],[5,6],[7,8]]
```
