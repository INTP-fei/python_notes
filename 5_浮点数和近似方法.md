# 浮点数与近似方法
## 二进制分数
| num | 余数 | 结果字符串 |
|-----|------|------------|
| 19  | 1    | 1          |
| 9   | 1    | 11         |
| 4   | 0    | 011        |
| 2   | 0    | 0011       |
| 1   | 1    | 10011      |
| 0   | -    | 10011      |
#### 处理负数
- 如果输入数字为负：
    - 设置一个负标志。
    - 使用相同的算法转换绝对值。
    - 在最终的二进制结果前加上负号。
### 十进制分数转换为二进制小数
1. **转换步骤**
   1. **确定十进制分数**（例如，`0.375 = 3/8`）。
   2. **找到最小的 2 的幂**，以乘以十进制分数以得到一个整数。
   3. **将结果整数转换为二进制**。
   4. **通过将二进制结果除以相同的 2 的幂来调整**。
2. **示例：转换 0.375**
   - 将 `0.375` 乘以 `8 (2³)` 得到 `3`。
   - 将 `3` 转换为二进制：*3*<sub>10</sub> = *11*<sub>2</sub> 。
   - 最终的二进制表示：将 *11*<sub>2</sub> 除以 2，结果为 *0.011*<sub>2</sub>。
3. 代码
```python
x = float(input('Enter a decimal number between 0 and 1: '))

p = 0
while ((2**p)*x)%1 != 0:
    print(f'Remainder = {str((2**p)*x - int((2**p)*x))}')
    p += 1

num = int(x*(2**p))

result = '' # 创建一个空字符串 result，它将用来存放最终的二进制字符串。
if num == 0:
    result = '0'
while num > 0:
    result = str(num%2) + result
    num = num//2

for i in range(p - len(result)):
    result = '0' + result

result = result[0:-p] + '.' + result[-p:]
print(f'The binary representation of the decimal {str(x)} is {str(result)}')
```
##  浮点数
1. **组成**：<mark>有效数字+二的幂</mark>
    - (1,1) -> 1·2<sup>-1</sup>(二的幂次表示二进制下的小数点的移动) -> *10*<sub>2</sub>(转化为二进制) -> 2.0
    - (1,-1) -> 1·2<sup>-1</sup> -> *0.1*<sub>2</sub> -> 0.5
    - (125,-2) -> 125·2<sup>-2</sup> -> *11111.01*<sub>2</sub>(内存中表示的实际数字) -> 31.25
2. **使用一个有限的比特集来表示一个潜在的无限的比特集**
  - 浮点表示 
    -  内存中数字的表示，特别是分数，通常不精确，因为分配的<mark>位数</mark>有限。
    - 例如，如果一个数字需要的位数超过可用位数（例如， 0.1需要 50 位），则**会被截断，导致近似误差**。 
    - 像0.1这样的数字在计算机内部实际上是一个近似值，我们不能完美的储存这个数字。
  -  ⚠️ 浮点算术中的**误差累积**
     -   现代计算机通常使用 32 或 64 位来表示有效数字。
     -  如果表示超过分配的位数，数字会被近似，从而导致计算中的潜在错误。
     -  **累积误差：在多次操作中，小的误差可能会累积，影响最终结果**。
3.  浮点数比较的重要性
     - 在比较浮点数时，避免使用相等运算符 ( == )，因为可能存在不准确性。
    - 测试两个浮点数之间的差异是否在一个小阈值（epsilon）内。
## 🔍 近似方法
1. 猜测和检查方法：一种简单的算法，通过迭代潜在解决方案，直到找到正确的答案。
2. 猜测和检查的局限性
   - 猜测和检查 方法的局限在于它并不提供非完美平方根的实际近似。
    - 例如，它可以确定一个数字不是完美平方，但无法近似平方根本身。

3. **近似法（出现源于穷举枚举的限制）通常不会给我们一个正确答案。它通常会给我们一个足够好的近似值。**
4. 近似中的关键概念
   - **浮点数：对近似方法很重要，因为它们允许更精确的计算。**
    - **近似方法使用较小的增量（例如，0.1、0.01）来接近平方根的近似值，而不是使用整数。**
5. 定义“足够好”
找到一个r使得r<sup>2</sup>在给定的（小的）距离内接近x。
            **∣r<sup>2</sup>−x∣<ϵ**
#### 近似算法步骤
1. 初始化：
   - 从一个已知过小的猜测开始
   - 设置两个参数：
      -  **Epsilon (ϵ)**：定义我们希望答案接近的程度。
      -  **增量**：我们改变猜测的量（例如，0.1、0.01、0.0001）。
2. 迭代猜测：
   - 检查猜测是否在 ϵ 边界内。
   - 如果不在，则按所选增量增加猜测，并重复，直到猜测足够好。
#### 近似算法中设置的参数
   1. epsilon (ϵ)：定义我们希望答案接近的程度。
   2. 增量：我们改变猜测的量（例如，0.1、0.01、0.0001）。
3. 性能将根据这些值而变化
   - 速度
   - 准确度
   - 减少增量 -> 程序运行更慢，但可能得到好的答案
   - 增大ϵ -> 答案准确度降低，程序运行更快
#### 近似法总结
- 我们以一个小的增量进行增加
- 当足够接近时我们停止（精确值是不可能的）
#### 代码实现
```python
# 参数
x = 36  # 要找平方根的数字
epsilon = 0.01  # 可接受的误差
increment = 0.0001  # 猜测增量
num_guesses = 0  # 猜测计数

# 初始猜测
guess = 0

# 循环寻找平方根
while abs(guess**2 - x) >= epsilon: # for循环的步长是以整数增加的故不可以用for循环
    guess += increment
    num_guesses += 1

print(f"平方根 {x} 的近似值是 {guess}，共猜测了 {num_guesses} 次。")
```
| 目标数字 (x) | 近似结果 | 猜测次数 |
|---------------|----------|----------|
| 36            | 5.9991   | 59,992   |
| 24            | 4.89     | 变化     |
| 2             | 1.41     | 变化     |
| 54321         | 循环可能不终止 | 潜在问题 |
#### 浮点错误
  - 由于以二进制格式表示数字的限制，可能会发生浮点错误，导致意外结果。
  - 例如，平方根24的结果可能是 4.89，表明存在小的误差。
#### 循环的终止
  - 确保循环最终会终止是至关重要的。
  - 在增量过小或目标数字过大时，循环可能会过度运行或无限循环。
#### 当x值过大时
```python
x = 54321
epsilon = 0.01
num_guesses = 0
guess = 0.0
increment = 0.0001
while abs(guess**2 - x) >= epsilon:
    guess += increment
    num_guesses += 1
    if num_guesses%100000 == 0:
        print(f'Current guess = {guess}')
        print(f'Current guess**2 - x = {abs(guess*guess - x)}')
    if num_guesses%1000000 == 0:
        input('continue?')
print(f'num_guesses = {num_guesses}')
print(f'{guess} is close to square root of {x}')
```
- 递减函数最终开始递增
    - 因此没有按预期退出循环
- 我们越过了目标
    - 也就是说，我们从一个太远但太小的值跳到了一个太远但太大的值
```python
x = 54321
epsilon = 0.01
num_guesses = 0
guess = 0.0
increment = 0.0001  # try with 0.00001
while abs(guess**2 - x) >= epsilon and guess**2 <= x:
    guess += increment
    num_guesses += 1
print(f'num_guesses = {num_guesses}')
if abs(guess**2 - x) >= epsilon:
    print(f'Failed on square root of {x}')
    print(f'Last guess was {guess}')
    print(f'Last guess squared is {guess*guess}')
else:
    print(f'{guess} is close to square root of {x}')
    
```
#### 调整增量
- 减少增量：
  - 为了提高精度，我们可以减少增量值（例如，从0.0001减少到0.00001）。
  - 结果：增加猜测次数，但提高精度。
  
| 增量变化 | 猜测次数   | 结果                     |
|----------|------------|--------------------------|
| 0.0001   | 2,300,000  | 未能找到平方根           |
| 0.00001  | 23,000,000 | 找到接近目标的平方根     |
- 考虑事项：
    - 较慢的程序虽然需要更多猜测，但可以产生准确的结果，代价是执行时间。
    - 必须在速度（较少的猜测）和精度（较小的增量）之间找到平衡。
#### 使用近似方法有可能超过误差范围，你需要其他结束条件
   - 检查我们是否在误差范围内
   - 如何停止程序而不让它陷入无限循环
# 课后
1. **课后作业**